/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of RRDs.xs. Do not edit this file, edit RRDs.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "RRDs.xs"
#ifdef __cplusplus
extern "C" {
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef __cplusplus
}
#endif

/*
 * rrd_tool.h includes config.h, but at least on Ubuntu Breezy Badger
 * 5.10 with gcc 4.0.2, the C preprocessor picks up Perl's config.h
 * which is included from the Perl includes and never reads rrdtool's
 * config.h.  Without including rrdtool's config.h, this module does
 * not compile, so include it here with an explicit path.
 *
 * Because rrdtool's config.h redefines VERSION which is originally
 * set via Perl's Makefile.PL and passed down to the C compiler's
 * command line, save the original value and reset it after the
 * includes.
 */
#define VERSION_SAVED VERSION
#undef VERSION
#ifndef WIN32
#include "../../rrd_config.h"
#endif
#include "../../src/rrd_tool.h"
#undef VERSION
#define VERSION VERSION_SAVED
#undef VERSION_SAVED

#define rrdcode(name) \
		argv = (char **) malloc((items+1)*sizeof(char *));\
		argv[0] = "dummy";\
		for (i = 0; i < items; i++) { \
		    STRLEN len; \
		    char *handle= SvPV(ST(i),len);\
		    /* actually copy the data to make sure possible modifications \
		       on the argv data does not backfire into perl */ \
		    argv[i+1] = (char *) malloc((strlen(handle)+1)*sizeof(char)); \
		    strcpy(argv[i+1],handle); \
 	        } \
		rrd_clear_error();\
		RETVAL=name(items+1,argv); \
		for (i=0; i < items; i++) {\
		    free(argv[i+1]);\
		} \
		free(argv);\
		\
		if (rrd_test_error()) XSRETURN_UNDEF;

#define hvs(VAL) hv_store_ent(hash, sv_2mortal(newSVpv(data->key,0)),VAL,0)		    

#define rrdinfocode(name) \
		/* prepare argument list */ \
		argv = (char **) malloc((items+1)*sizeof(char *)); \
		argv[0] = "dummy"; \
		for (i = 0; i < items; i++) { \
		    STRLEN len; \
		    char *handle= SvPV(ST(i),len); \
		    /* actually copy the data to make sure possible modifications \
		       on the argv data does not backfire into perl */ \
		    argv[i+1] = (char *) malloc((strlen(handle)+1)*sizeof(char)); \
		    strcpy(argv[i+1],handle); \
 	        } \
                rrd_clear_error(); \
                data=name(items+1, argv); \
                for (i=0; i < items; i++) { \
		    free(argv[i+1]); \
		} \
		free(argv); \
                if (rrd_test_error()) XSRETURN_UNDEF; \
                hash = newHV(); \
   	        save=data; \
                while (data) { \
		/* the newSV will get copied by hv so we create it as a mortal \
           to make sure it does not keep hanging round after the fact */ \
		    switch (data->type) { \
		    case RD_I_VAL: \
			if (isnan(data->value.u_val)) \
			    hvs(newSV(0)); \
			else \
			    hvs(newSVnv(data->value.u_val)); \
			break; \
			case RD_I_INT: \
			hvs(newSViv(data->value.u_int)); \
			break; \
		    case RD_I_CNT: \
			hvs(newSViv(data->value.u_cnt)); \
			break; \
		    case RD_I_STR: \
			hvs(newSVpv(data->value.u_str,0)); \
			break; \
		    case RD_I_BLO: \
			hvs(newSVpv(data->value.u_blo.ptr,data->value.u_blo.size)); \
			break; \
		    } \
		    data = data->next; \
	        } \
            rrd_info_free(save); \
            RETVAL = newRV_noinc((SV*)hash);

/*
 * should not be needed if libc is linked (see ntmake.pl)
#ifdef WIN32
 #define free free
 #define malloc malloc
 #define realloc realloc
#endif
*/


#line 126 "RRDs.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 169 "RRDs.c"

XS(XS_RRDs_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 129 "RRDs.xs"
		if (! rrd_test_error()) XSRETURN_UNDEF;
                RETVAL = newSVpv(rrd_get_error(),0);
#line 186 "RRDs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_RRDs_last); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_last)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 138 "RRDs.xs"
      int i;
      char **argv;
#line 207 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 141 "RRDs.xs"
              rrdcode(rrd_last);
#line 212 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RRDs_first); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_first)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 149 "RRDs.xs"
      int i;
      char **argv;
#line 232 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 152 "RRDs.xs"
              rrdcode(rrd_first);
#line 237 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RRDs_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 160 "RRDs.xs"
        int i;
	char **argv;
#line 257 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 163 "RRDs.xs"
		rrdcode(rrd_create);
	        RETVAL = 1;
#line 263 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RRDs_update); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_update)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 172 "RRDs.xs"
        int i;
	char **argv;
#line 283 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 175 "RRDs.xs"
		rrdcode(rrd_update);
       	        RETVAL = 1;
#line 289 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RRDs_tune); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_tune)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 184 "RRDs.xs"
        int i;
	char **argv;
#line 309 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 187 "RRDs.xs"
		rrdcode(rrd_tune);
       	        RETVAL = 1;
#line 315 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RRDs_graph); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_graph)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 196 "RRDs.xs"
	char **calcpr=NULL;
	int i,xsize,ysize;
	double ymin,ymax;
	char **argv;
	AV *retar;
#line 340 "RRDs.c"
	SV *	RETVAL;
#line 202 "RRDs.xs"
		argv = (char **) malloc((items+1)*sizeof(char *));
		argv[0] = "dummy";
		for (i = 0; i < items; i++) { 
		    STRLEN len;
		    char *handle = SvPV(ST(i),len);
		    /* actually copy the data to make sure possible modifications
		       on the argv data does not backfire into perl */ 
		    argv[i+1] = (char *) malloc((strlen(handle)+1)*sizeof(char));
		    strcpy(argv[i+1],handle);
 	        }
		rrd_clear_error();
		rrd_graph(items+1,argv,&calcpr,&xsize,&ysize,NULL,&ymin,&ymax); 
		for (i=0; i < items; i++) {
		    free(argv[i+1]);
		}
		free(argv);

		if (rrd_test_error()) {
			if(calcpr)
			   for(i=0;calcpr[i];i++)
				rrd_freemem(calcpr[i]);
			XSRETURN_UNDEF;
		}
		retar=newAV();
		if(calcpr){
			for(i=0;calcpr[i];i++){
				 av_push(retar,newSVpv(calcpr[i],0));
				 rrd_freemem(calcpr[i]);
			}
			rrd_freemem(calcpr);
		}
		EXTEND(sp,4);
		PUSHs(sv_2mortal(newRV_noinc((SV*)retar)));
		PUSHs(sv_2mortal(newSViv(xsize)));
		PUSHs(sv_2mortal(newSViv(ysize)));
#line 378 "RRDs.c"
	PUTBACK;
	return;
    }
}


XS(XS_RRDs_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 242 "RRDs.xs"
		time_t        start,end;		
		unsigned long step, ds_cnt,i,ii;
		rrd_value_t   *data,*datai;
		char **argv;
		char **ds_namv;
		AV *retar,*line,*names;
#line 404 "RRDs.c"
	SV *	RETVAL;
#line 249 "RRDs.xs"
		argv = (char **) malloc((items+1)*sizeof(char *));
		argv[0] = "dummy";
		for (i = 0; i < items; i++) { 
		    STRLEN len;
		    char *handle= SvPV(ST(i),len);
		    /* actually copy the data to make sure possible modifications
		       on the argv data does not backfire into perl */ 
		    argv[i+1] = (char *) malloc((strlen(handle)+1)*sizeof(char));
		    strcpy(argv[i+1],handle);
 	        }
		rrd_clear_error();
		rrd_fetch(items+1,argv,&start,&end,&step,&ds_cnt,&ds_namv,&data); 
		for (i=0; i < items; i++) {
		    free(argv[i+1]);
		}
		free(argv);
		if (rrd_test_error()) XSRETURN_UNDEF;
                /* convert the ds_namv into perl format */
		names=newAV();
		for (ii = 0; ii < ds_cnt; ii++){
		    av_push(names,newSVpv(ds_namv[ii],0));
		    rrd_freemem(ds_namv[ii]);
		}
		rrd_freemem(ds_namv);			
		/* convert the data array into perl format */
		datai=data;
		retar=newAV();
		for (i = start+step; i <= end; i += step){
			line = newAV();
			for (ii = 0; ii < ds_cnt; ii++){
 			  av_push(line,(isnan(*datai) ? newSV(0) : newSVnv(*datai)));
			  datai++;
			}
			av_push(retar,newRV_noinc((SV*)line));
		}
		rrd_freemem(data);
		EXTEND(sp,5);
		PUSHs(sv_2mortal(newSViv(start+step)));
		PUSHs(sv_2mortal(newSViv(step)));
		PUSHs(sv_2mortal(newRV_noinc((SV*)names)));
		PUSHs(sv_2mortal(newRV_noinc((SV*)retar)));
#line 448 "RRDs.c"
	PUTBACK;
	return;
    }
}


XS(XS_RRDs_times); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_times)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "start, end");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	start = (char *)SvPV_nolen(ST(0));
	char *	end = (char *)SvPV_nolen(ST(1));
#line 296 "RRDs.xs"
		rrd_time_value_t start_tv, end_tv;
		char    *parsetime_error = NULL;
		time_t	start_tmp, end_tmp;
#line 474 "RRDs.c"
	SV *	RETVAL;
#line 300 "RRDs.xs"
		rrd_clear_error();
		if ((parsetime_error = rrd_parsetime(start, &start_tv))) {
			rrd_set_error("start time: %s", parsetime_error);
			XSRETURN_UNDEF;
		}
		if ((parsetime_error = rrd_parsetime(end, &end_tv))) {
			rrd_set_error("end time: %s", parsetime_error);
			XSRETURN_UNDEF;
		}
		if (rrd_proc_start_end(&start_tv, &end_tv, &start_tmp, &end_tmp) == -1) {
			XSRETURN_UNDEF;
		}
		EXTEND(sp,2);
		PUSHs(sv_2mortal(newSVuv(start_tmp)));
		PUSHs(sv_2mortal(newSVuv(end_tmp)));
#line 492 "RRDs.c"
	PUTBACK;
	return;
    }
}


XS(XS_RRDs_xport); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_xport)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 320 "RRDs.xs"
                time_t start,end;		
                int xsize;
		unsigned long step, col_cnt,row_cnt,i,ii;
		rrd_value_t *data,*ptr;
                char **argv,**legend_v;
		AV *retar,*line,*names;
#line 518 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 327 "RRDs.xs"
		argv = (char **) malloc((items+1)*sizeof(char *));
		argv[0] = "dummy";
		for (i = 0; i < items; i++) { 
		    STRLEN len;
		    char *handle = SvPV(ST(i),len);
		    /* actually copy the data to make sure possible modifications
		       on the argv data does not backfire into perl */ 
		    argv[i+1] = (char *) malloc((strlen(handle)+1)*sizeof(char));
		    strcpy(argv[i+1],handle);
 	        }
		rrd_clear_error();
		rrd_xport(items+1,argv,&xsize,&start,&end,&step,&col_cnt,&legend_v,&data); 
		for (i=0; i < items; i++) {
		    free(argv[i+1]);
		}
		free(argv);
		if (rrd_test_error()) XSRETURN_UNDEF;

                /* convert the legend_v into perl format */
		names=newAV();
		for (ii = 0; ii < col_cnt; ii++){
		    av_push(names,newSVpv(legend_v[ii],0));
		    rrd_freemem(legend_v[ii]);
		}
		rrd_freemem(legend_v);			

		/* convert the data array into perl format */
		ptr=data;
		retar=newAV();
		for (i = start+step; i <= end; i += step){
			line = newAV();
			for (ii = 0; ii < col_cnt; ii++){
 			  av_push(line,(isnan(*ptr) ? newSV(0) : newSVnv(*ptr)));
			  ptr++;
			}
			av_push(retar,newRV_noinc((SV*)line));
		}
		rrd_freemem(data);

		EXTEND(sp,7);
		PUSHs(sv_2mortal(newSViv(start+step)));
		PUSHs(sv_2mortal(newSViv(end)));
		PUSHs(sv_2mortal(newSViv(step)));
		PUSHs(sv_2mortal(newSViv(col_cnt)));
		PUSHs(sv_2mortal(newRV_noinc((SV*)names)));
		PUSHs(sv_2mortal(newRV_noinc((SV*)retar)));
#line 568 "RRDs.c"
	PUTBACK;
	return;
    }
}


XS(XS_RRDs_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 378 "RRDs.xs"
		rrd_info_t *data,*save;
                int i;
                char **argv;
		HV *hash;
#line 590 "RRDs.c"
	SV *	RETVAL;
#line 383 "RRDs.xs"
		rrdinfocode(rrd_info);	
#line 594 "RRDs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_RRDs_updatev); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_updatev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 391 "RRDs.xs"
		rrd_info_t *data,*save;
                int i;
                char **argv;
		HV *hash;
#line 617 "RRDs.c"
	SV *	RETVAL;
#line 396 "RRDs.xs"
		rrdinfocode(rrd_update_v);	
#line 621 "RRDs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_RRDs_graphv); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_graphv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 404 "RRDs.xs"
		rrd_info_t *data,*save;
                int i;
                char **argv;
		HV *hash;
#line 644 "RRDs.c"
	SV *	RETVAL;
#line 409 "RRDs.xs"
		rrdinfocode(rrd_graph_v);	
#line 648 "RRDs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_RRDs_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_dump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 417 "RRDs.xs"
        int i;
       char **argv;
#line 669 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 420 "RRDs.xs"
               rrdcode(rrd_dump);
                       RETVAL = 1;
#line 675 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RRDs_restore); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_restore)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 429 "RRDs.xs"
        int i;
       char **argv;
#line 695 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 432 "RRDs.xs"
               rrdcode(rrd_restore);
                       RETVAL = 1;
#line 701 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifndef WIN32
#define XSubPPtmpAAAA 1


XS(XS_RRDs_flushcached); /* prototype to pass -Wmissing-prototypes */
XS(XS_RRDs_flushcached)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 442 "RRDs.xs"
	int i;
	char **argv;
#line 724 "RRDs.c"
	int	RETVAL;
	dXSTARG;
#line 445 "RRDs.xs"
		rrdcode(rrd_flushcached);
#line 729 "RRDs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS(boot_RRDs); /* prototype to pass -Wmissing-prototypes */
XS(boot_RRDs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("RRDs::error", XS_RRDs_error, file);
        newXSproto("RRDs::last", XS_RRDs_last, file, "@");
        newXSproto("RRDs::first", XS_RRDs_first, file, "@");
        newXSproto("RRDs::create", XS_RRDs_create, file, "@");
        newXSproto("RRDs::update", XS_RRDs_update, file, "@");
        newXSproto("RRDs::tune", XS_RRDs_tune, file, "@");
        newXSproto("RRDs::graph", XS_RRDs_graph, file, "@");
        newXSproto("RRDs::fetch", XS_RRDs_fetch, file, "@");
        newXS("RRDs::times", XS_RRDs_times, file);
        newXSproto("RRDs::xport", XS_RRDs_xport, file, "@");
        newXSproto("RRDs::info", XS_RRDs_info, file, "@");
        newXSproto("RRDs::updatev", XS_RRDs_updatev, file, "@");
        newXSproto("RRDs::graphv", XS_RRDs_graphv, file, "@");
        newXSproto("RRDs::dump", XS_RRDs_dump, file, "@");
        newXSproto("RRDs::restore", XS_RRDs_restore, file, "@");
#if XSubPPtmpAAAA
        newXSproto("RRDs::flushcached", XS_RRDs_flushcached, file, "@");
#endif

    /* Initialisation Section */

#line 119 "RRDs.xs"
#ifdef MUST_DISABLE_SIGFPE
	signal(SIGFPE,SIG_IGN);
#endif
#ifdef MUST_DISABLE_FPMASK
	fpsetmask(0);
#endif 

#if XSubPPtmpAAAA
#endif
#line 784 "RRDs.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

